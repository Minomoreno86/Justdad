//
//  CoreDataModels.swift
//  SoloPap치 - Core Data model definitions
//
//  Data models for offline-first architecture with SQLCipher encryption
//

import Foundation
import SwiftData

// MARK: - Visit Model
@Model
final class Visit {
    var id: UUID
    var title: String
    var startDate: Date
    var endDate: Date
    var location: String?
    var notes: String?
    var typeRawValue: String // Store enum as string to avoid type conflicts
    var isCompleted: Bool
    var reminderMinutes: Int?
    var isRecurring: Bool
    var eventKitIdentifier: String?
    var createdAt: Date
    var updatedAt: Date
    
    init(title: String, startDate: Date, endDate: Date, typeRawValue: String, location: String? = nil, notes: String? = nil, reminderMinutes: Int? = nil, isRecurring: Bool = false) {
        self.id = UUID()
        self.title = title
        self.startDate = startDate
        self.endDate = endDate
        self.typeRawValue = typeRawValue
        self.location = location
        self.notes = notes
        self.reminderMinutes = reminderMinutes
        self.isRecurring = isRecurring
        self.eventKitIdentifier = nil
        self.isCompleted = false
        self.createdAt = Date()
        self.updatedAt = Date()
    }
    
    // Convenience computed property for type conversion
    var visitType: String {
        get { typeRawValue }
        set { 
            typeRawValue = newValue
            updatedAt = Date()
        }
    }
}

// MARK: - Financial Entry Model
@Model
final class FinancialEntry {
    var id: UUID
    var title: String
    var amount: Decimal
    var category: ExpenseCategory
    var date: Date
    var notes: String?
    var receiptImagePath: String? // Path to encrypted image file
    var isRecurring: Bool
    var recurringInterval: Int? // Days between recurrences
    var tags: [String]
    var createdAt: Date
    var updatedAt: Date
    
    enum ExpenseCategory: String, Codable, CaseIterable {
        case education = "education"
        case health = "health"
        case food = "food"
        case clothing = "clothing"
        case transportation = "transportation"
        case entertainment = "entertainment"
        case gifts = "gifts"
        case childSupport = "child_support"
        case other = "other"
        
        var displayName: String {
            switch self {
            case .education: return "Educaci칩n"
            case .health: return "Salud"
            case .food: return "Alimentaci칩n"
            case .clothing: return "Vestimenta"
            case .transportation: return "Transporte"
            case .entertainment: return "Entretenimiento"
            case .gifts: return "Regalos"
            case .childSupport: return "Manutenci칩n"
            case .other: return "Otros"
            }
        }
        
        var icon: String {
            switch self {
            case .education: return "book.fill"
            case .health: return "cross.case.fill"
            case .food: return "fork.knife"
            case .clothing: return "tshirt.fill"
            case .transportation: return "car.fill"
            case .entertainment: return "gamecontroller.fill"
            case .gifts: return "gift.fill"
            case .childSupport: return "house.fill"
            case .other: return "ellipsis.circle.fill"
            }
        }
        
        var color: String {
            switch self {
            case .education: return "blue"
            case .health: return "red"
            case .food: return "green"
            case .clothing: return "purple"
            case .transportation: return "orange"
            case .entertainment: return "pink"
            case .gifts: return "yellow"
            case .childSupport: return "brown"
            case .other: return "gray"
            }
        }
    }
    
    init(title: String, amount: Decimal, category: ExpenseCategory, date: Date = Date(), notes: String? = nil, isRecurring: Bool = false) {
        self.id = UUID()
        self.title = title
        self.amount = amount
        self.category = category
        self.date = date
        self.notes = notes
        self.receiptImagePath = nil
        self.isRecurring = isRecurring
        self.recurringInterval = nil
        self.tags = []
        self.createdAt = Date()
        self.updatedAt = Date()
    }
    
    // Update method to mark as modified
    func updateTimestamp() {
        self.updatedAt = Date()
    }
}

// MARK: - Emotional Entry Model
@Model
final class EmotionalEntry {
    var id: UUID
    var mood: MoodLevel
    var note: String?
    var date: Date
    var energyLevel: Int // 1-10
    var stressLevel: Int // 1-10
    var sleepQuality: Int // 1-10
    var tags: [String] // e.g., "children", "work", "exercise"
    var triggers: [String] // What caused this mood
    var coping: [String] // What helped or could help
    var createdAt: Date
    
    enum MoodLevel: Int, Codable, CaseIterable {
        case veryLow = 1
        case low = 2
        case neutral = 3
        case good = 4
        case excellent = 5
        
        var emoji: String {
            switch self {
            case .veryLow: return "游땩"
            case .low: return "游땞"
            case .neutral: return "游땛"
            case .good: return "游땕"
            case .excellent: return "游땏"
            }
        }
        
        var description: String {
            switch self {
            case .veryLow: return "Muy Triste"
            case .low: return "Triste"
            case .neutral: return "Neutral"
            case .good: return "Feliz"
            case .excellent: return "Muy Feliz"
            }
        }
        
        var color: String {
            switch self {
            case .veryLow: return "red"
            case .low: return "orange"
            case .neutral: return "yellow"
            case .good: return "lightgreen"
            case .excellent: return "green"
            }
        }
    }
    
    init(mood: MoodLevel, note: String? = nil, date: Date = Date()) {
        self.id = UUID()
        self.mood = mood
        self.note = note
        self.date = date
        self.energyLevel = 5
        self.stressLevel = 5
        self.sleepQuality = 5
        self.tags = []
        self.triggers = []
        self.coping = []
        self.createdAt = Date()
    }
    
    // Weekly mood average calculation helper
    static func weeklyAverage(entries: [EmotionalEntry]) -> Double {
        guard !entries.isEmpty else { return 0.0 }
        let sum = entries.reduce(0) { $0 + $1.mood.rawValue }
        return Double(sum) / Double(entries.count)
    }
    
    // Check if this is a positive mood entry
    var isPositive: Bool {
        return mood.rawValue >= 4
    }
}

// MARK: - Diary Entry Model
@Model
final class DiaryEntry {
    var id: UUID
    var title: String?
    var content: String
    var mood: String // Emoji representation
    var date: Date
    var attachments: [DiaryAttachment]
    var isEncrypted: Bool
    var encryptionKey: String? // Reference to keychain key
    var tags: [String]
    var location: String? // Optional location where entry was written
    var wordCount: Int
    var createdAt: Date
    var updatedAt: Date
    
    init(content: String, title: String? = nil, mood: String = "游땛", date: Date = Date()) {
        self.id = UUID()
        self.title = title
        self.content = content
        self.mood = mood
        self.date = date
        self.attachments = []
        self.isEncrypted = true
        self.encryptionKey = nil // Will be set when encrypting
        self.tags = []
        self.location = nil
        self.wordCount = content.split(separator: " ").count
        self.createdAt = Date()
        self.updatedAt = Date()
    }
    
    // Update content and recalculate word count
    func updateContent(_ newContent: String) {
        self.content = newContent
        self.wordCount = newContent.split(separator: " ").count
        self.updatedAt = Date()
    }
    
    // Add attachment
    func addAttachment(_ attachment: DiaryAttachment) {
        attachments.append(attachment)
        updatedAt = Date()
    }
    
    // Check if entry has any media attachments
    var hasMediaAttachments: Bool {
        return attachments.contains { $0.type == .photo || $0.type == .audio }
    }
    
    // Get preview text (first 100 characters)
    var preview: String {
        if content.count <= 100 {
            return content
        }
        let index = content.index(content.startIndex, offsetBy: 100)
        return String(content[..<index]) + "..."
    }
}

// MARK: - Diary Attachment Model
@Model
final class DiaryAttachment {
    var id: UUID
    var type: AttachmentType
    var filePath: String // Encrypted file path
    var originalFileName: String?
    var fileSize: Int64
    var createdAt: Date
    
    enum AttachmentType: String, Codable {
        case photo = "photo"
        case audio = "audio"
        case document = "document"
    }
    
    init(type: AttachmentType, filePath: String, originalFileName: String? = nil, fileSize: Int64 = 0) {
        self.id = UUID()
        self.type = type
        self.filePath = filePath
        self.originalFileName = originalFileName
        self.fileSize = fileSize
        self.createdAt = Date()
    }
}

// MARK: - Community Post Model (for caching)
@Model
final class CommunityPost {
    var id: UUID
    var title: String
    var content: String
    var category: String
    var isAnonymous: Bool
    var authorName: String?
    var likesCount: Int
    var commentsCount: Int
    var createdAt: Date
    var lastSyncAt: Date
    
    init(title: String, content: String, category: String, isAnonymous: Bool = false, authorName: String? = nil) {
        self.id = UUID()
        self.title = title
        self.content = content
        self.category = category
        self.isAnonymous = isAnonymous
        self.authorName = authorName
        self.likesCount = 0
        self.commentsCount = 0
        self.createdAt = Date()
        self.lastSyncAt = Date()
    }
}

// MARK: - User Preferences Model
@Model
final class UserPreferences {
    var id: UUID
    var biometricAuthEnabled: Bool
    var darkModeEnabled: Bool
    var preferredLanguage: String
    var notificationsEnabled: Bool
    var reminderSettings: ReminderSettings
    var onboardingCompleted: Bool
    var lastBackupDate: Date?
    var updatedAt: Date
    
    init() {
        self.id = UUID()
        self.biometricAuthEnabled = false
        self.darkModeEnabled = false
        self.preferredLanguage = "es"
        self.notificationsEnabled = true
        self.reminderSettings = ReminderSettings()
        self.onboardingCompleted = false
        self.updatedAt = Date()
    }
}

// MARK: - Reminder Settings
struct ReminderSettings: Codable {
    var visitReminders: Bool = true
    var emotionalCheckIn: Bool = true
    var communityUpdates: Bool = false
    var backupReminders: Bool = true
    
    init(visitReminders: Bool = true, emotionalCheckIn: Bool = true, communityUpdates: Bool = false, backupReminders: Bool = true) {
        self.visitReminders = visitReminders
        self.emotionalCheckIn = emotionalCheckIn
        self.communityUpdates = communityUpdates
        self.backupReminders = backupReminders
    }
}
